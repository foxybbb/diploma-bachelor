

\appendix
\newpage
\null\vspace{\fill} % Add vertical space before the text block

\begin{center}
	\addcontentsline{toc}{section}{APPENDIX}
	{\fontsize{14}{14}\selectfont \textbf{APPENDIX}}
\end{center}
\vspace{\fill}\null % Add vertical space after the text block

\newpage
\apendixsection{Table comparing the results of thousands of operations per second at 1 MHz for each MCs}

% \usepackage{color}
% \usepackage{tabularray}
\definecolor{SweetCorn}{rgb}{0.984,0.917,0.517}
\definecolor{SweetCorn1}{rgb}{0.988,0.917,0.517}
\definecolor{MacaroniandCheese}{rgb}{0.984,0.678,0.47}
\definecolor{Froly}{rgb}{0.972,0.482,0.431}
\definecolor{Froly1}{rgb}{0.972,0.454,0.427}
\definecolor{Carnation}{rgb}{0.972,0.423,0.419}
\definecolor{YellowGreen}{rgb}{0.768,0.854,0.505}
\definecolor{Feijoa}{rgb}{0.725,0.843,0.501}
\definecolor{YellowGreen1}{rgb}{0.756,0.85,0.505}
\definecolor{Flax}{rgb}{0.933,0.901,0.513}
\definecolor{SweetCorn2}{rgb}{0.976,0.917,0.517}
\definecolor{Salomie}{rgb}{1,0.921,0.517}
\definecolor{SaharaSand}{rgb}{0.96,0.913,0.517}
\definecolor{AtomicTangerine}{rgb}{0.98,0.603,0.454}
\definecolor{SaharaSand1}{rgb}{0.941,0.905,0.517}
\definecolor{SaharaSand2}{rgb}{0.945,0.905,0.517}
\definecolor{SweetCorn3}{rgb}{0.972,0.913,0.517}
\definecolor{Salomie1}{rgb}{0.996,0.886,0.509}
\definecolor{Froly2}{rgb}{0.972,0.466,0.427}
\definecolor{Carnation1}{rgb}{0.972,0.431,0.423}
\definecolor{Salmon}{rgb}{0.976,0.509,0.435}
\definecolor{Carnation2}{rgb}{0.972,0.411,0.419}
\definecolor{SweetCorn4}{rgb}{0.98,0.917,0.517}
\definecolor{SweetCorn5}{rgb}{0.992,0.921,0.517}
\definecolor{Froly3}{rgb}{0.972,0.462,0.427}
\definecolor{Carnation3}{rgb}{0.972,0.435,0.423}
\definecolor{MacaroniandCheese1}{rgb}{0.984,0.69,0.47}
\definecolor{Carnation4}{rgb}{0.972,0.415,0.419}
\definecolor{SweetCorn6}{rgb}{0.968,0.913,0.517}
\definecolor{SaharaSand3}{rgb}{0.956,0.909,0.517}
\definecolor{AtomicTangerine1}{rgb}{0.98,0.623,0.458}
\definecolor{Salmon1}{rgb}{0.98,0.556,0.447}
\definecolor{SweetCorn7}{rgb}{0.964,0.913,0.517}
\definecolor{Froly4}{rgb}{0.972,0.458,0.427}
\definecolor{Froly5}{rgb}{0.976,0.486,0.431}
\definecolor{Froly6}{rgb}{0.976,0.498,0.435}
\definecolor{Froly7}{rgb}{0.976,0.494,0.435}
\definecolor{Froly8}{rgb}{0.972,0.478,0.431}
\definecolor{Carnation5}{rgb}{0.972,0.427,0.419}
\definecolor{DeYork}{rgb}{0.466,0.768,0.49}
\definecolor{DeYork1}{rgb}{0.478,0.772,0.49}
\definecolor{Fern}{rgb}{0.388,0.745,0.482}
\definecolor{YellowGreen2}{rgb}{0.784,0.858,0.505}
\definecolor{SaharaSand4}{rgb}{0.949,0.909,0.517}
\definecolor{SweetCorn8}{rgb}{0.988,0.921,0.517}
\definecolor{YellowGreen3}{rgb}{0.776,0.858,0.505}
\definecolor{Salmon2}{rgb}{0.976,0.552,0.447}
\definecolor{WildRice}{rgb}{0.901,0.894,0.513}
\definecolor{AtomicTangerine2}{rgb}{0.98,0.592,0.45}
\definecolor{Froly9}{rgb}{0.976,0.482,0.431}
\definecolor{Chardonnay}{rgb}{0.992,0.807,0.494}
\begin{table}[H]
	\centering
	\begin{adjustbox}{width=\textwidth}
		\begin{tblr}{
				cell{2}{2} = {SweetCorn,r},
				cell{2}{3} = {SweetCorn,r},
				cell{2}{4} = {SweetCorn1,r},
				cell{2}{5} = {MacaroniandCheese,r},
				cell{2}{6} = {Froly,r},
				cell{2}{7} = {Froly1,r},
				cell{2}{8} = {MacaroniandCheese,r},
				cell{2}{9} = {Carnation,r},
				cell{3}{2} = {YellowGreen,r},
				cell{3}{3} = {Feijoa,r},
				cell{3}{4} = {YellowGreen1,r},
				cell{3}{5} = {Flax,r},
				cell{3}{6} = {SweetCorn2,r},
				cell{3}{7} = {Salomie,r},
				cell{3}{8} = {SaharaSand,r},
				cell{3}{9} = {AtomicTangerine,r},
				cell{4}{2} = {SaharaSand1,r},
				cell{4}{3} = {SaharaSand2,r},
				cell{4}{4} = {SweetCorn3,r},
				cell{4}{5} = {Salomie1,r},
				cell{4}{6} = {Froly2,r},
				cell{4}{7} = {Carnation1,r},
				cell{4}{8} = {Salmon,r},
				cell{4}{9} = {Carnation2,r},
				cell{5}{2} = {SweetCorn4,r},
				cell{5}{3} = {SweetCorn,r},
				cell{5}{4} = {SweetCorn5,r},
				cell{5}{5} = {MacaroniandCheese,r},
				cell{5}{6} = {Froly3,r},
				cell{5}{7} = {Carnation3,r},
				cell{5}{8} = {MacaroniandCheese1,r},
				cell{5}{9} = {Carnation4,r},
				cell{6}{2} = {SweetCorn6,r},
				cell{6}{3} = {SweetCorn6,r},
				cell{6}{4} = {SaharaSand3,r},
				cell{6}{5} = {SweetCorn3,r},
				cell{6}{6} = {AtomicTangerine1,r},
				cell{6}{7} = {Salmon1,r},
				cell{6}{8} = {SweetCorn7,r},
				cell{6}{9} = {Froly4,r},
				cell{7}{2} = {Froly5,r},
				cell{7}{3} = {Froly6,r},
				cell{7}{4} = {Froly6,r},
				cell{7}{5} = {Froly7,r},
				cell{7}{6} = {Froly4,r},
				cell{7}{7} = {Froly1,r},
				cell{7}{8} = {Froly8,r},
				cell{7}{9} = {Carnation5,r},
				cell{8}{2} = {DeYork,r},
				cell{8}{3} = {DeYork1,r},
				cell{8}{4} = {Fern,r},
				cell{8}{5} = {YellowGreen2,r},
				cell{8}{6} = {SaharaSand4,r},
				cell{8}{7} = {SweetCorn8,r},
				cell{8}{8} = {YellowGreen3,r},
				cell{8}{9} = {Salmon2,r},
				cell{9}{2} = {SaharaSand1,r},
				cell{9}{3} = {SaharaSand1,r},
				cell{9}{4} = {WildRice,r},
				cell{9}{5} = {SweetCorn1,r},
				cell{9}{6} = {AtomicTangerine2,r},
				cell{9}{7} = {Froly9,r},
				cell{9}{8} = {Chardonnay,r},
				cell{9}{9} = {Carnation,r},
				hlines,
				vlines,
			}
			MCU                  & ~a~
			+~ b                 & a~
			-~ b                 & a~
			*~ b                 & a~
			/ b                  & sin(a)  & log(a) & sqrt(b) & pow(b, a)                                   \\
			ATmega328p~          & 6,952   & 7,205  & 6,251   & 2,015     & 0,598  & 0,403 & 2,017  & 0,190 \\
			ESP32                & 46,212  & 54,007 & 48,121  & 16,325    & 8,568  & 3,986 & 11,006 & 1,484 \\
			ESP8266~             & 14,412  & 13,861 & 8,852   & 3,497     & 0,485  & 0,239 & 0,787  & 0,082 \\
			RP2040 [Arduino IDE] & 7,815   & 7,226  & 5,489   & 2,022     & 0,455  & 0,273 & 2,103  & 0,122 \\
			RP2040 [C++ SDK]     & 10,132  & 9,699  & 11,717  & 9,266     & 1,625  & 1,139 & 10,719 & 0,435 \\
			RP2040 [MicroPython] & 0,629   & 0,707  & 0,723   & 0,681     & 0,441  & 0,400 & 0,568  & 0,215 \\
			STM32G431~           & 101,054 & 98,251 & 114,565 & 43,435    & 13,254 & 6,178 & 44,849 & 1,118 \\
			STM32G431 [FPU-OFF]  & 15,008  & 14,425 & 21,932  & 6,216     & 1,391  & 0,607 & 2,939  & 0,176
		\end{tblr}
	\end{adjustbox}
\end{table}

\newpage
\apendixsection{Code fragment of the RobotDK TCP command driver code}


\begin{figure}[H]
	\centering

	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{python}
import socket
import serial
import sys

TCP_IP = '127.0.0.1'  # Listen шз
TCP_PORT = 5005     # port 

# UART settings
UART_PORT = '/dev/serial0'  # UART1 port on Rasp
BAUD_RATE = 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
# Setup socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((TCP_IP, TCP_PORT))
s.listen(1)

print(f"Listening for TCP connections on {TCP_IP}:{TCP_PORT}")

conn, addr = s.accept()
 try:
    while True:
        data = conn.recv(1024)  # Buffer = 1024 
        if not data:
            break
        ser.write(data)  # Write data to UART

	\end{minted}
	\label{CodePython3}
\end{figure}

\newpage


\apendixsection{Software code Python simulation code for converting encoder rotation angle to total angle}

\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{python}
# Initialize variables
last_encoder_value = 0
full_rotation_count = 0
total_angle_degrees = 0
cpr = 4096  # Counts per revolution for the encoder

def update_angle(encoder_value):
    global last_encoder_value, full_rotation_count, total_angle_degrees, cpr
    # Calculate the change in encoder value
    d_value = encoder_value - last_encoder_value
    if d_value > cpr / 2: 
        full_rotation_count -= 1

    elif d_value < -cpr / 2:
        full_rotation_count += 1

    # Update the total angle in degrees, considering multiple rotations
    total_angle_degrees = (full_rotation_count * 360) + (encoder_value / cpr) * 360
    # Update last encoder value for the next call
    last_encoder_value = encoder_value
    return total_angle_degrees

# This loop simulates the encoder values changing
for i in range(10000): 
    encoder_value = i % cpr  # Simulate encoder value
    angle = update_angle(encoder_value)
    print(f"Total Angle: {angle} degrees")
	\end{minted}

\end{figure}


\newpage
\apendixsection{Code fragment of the encoder data processing function.}


\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{cpp}
float d_time;float d_angle;
uint16_t angle_data;
float resolution = 4096;
uint16_t now = __HAL_TIM_GET_COUNTER(&htim6);
//Calculate the time between the current and last measurements
d_time = now <= encoder->lastUpdateTime ? 0xffff - encoder->lastUpdateTime + now : now - encoder->lastUpdateTime;
EncoderGetAngle(encoder->handle, &angle_data);
//Track the number of revolutions
d_angle = (float)(angle_data - encoder->last_angle_data);
//If detected occurs, count it as a full revolution
if(abs(d_angle) > (0.8 * resolution) ){
	if(full_rotation_offset>0{
		d_angle += 2*PI;
	}else{
		d_angle += -2*PI
	}}
//to determine if an overflow has occurred
encoder->last_angle_data = angle_data;
encoder->angle_rad = encoder->full_rotation_offset + ((float)angle_data / (float)resolution) * 2*PI;
encoder->angle_deg = RADIANS_TO_DEGREES(encoder->angle_rad);
encoder->velocity_rad = ((encoder->angle_rad - encoder->angle_prev_rad) / d_time * 1000000.0f);
encoder->velocity_deg = ((encoder->angle_deg - encoder->angle_prev_deg) / d_time * 1000000.0f);
encoder->angle_prev_rad = encoder->angle_rad; // save angle rad
encoder->angle_prev_deg = encoder->angle_deg; // save angle deg
//Update time of last measurement
encoder->lastUpdateTime = __HAL_TIM_GET_COUNTER(&htim6);
	\end{minted}

\end{figure}


\newpage
\apendixsection{Code fragment for Vector Control Algorithm update}


\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{cpp}
void FOC_Update(uint16_t time_us,float setpoint_torque_current_mA,float setpoint_flux_current_mA,float phase_synchro_offset_rad,uint32_t closed_loop,float setpoint_velocity_dps){
    float phaseCurrents[3];
		// performance monitoring
        uint16_t startTime = __HAL_TIM_GET_COUNTER(&htim6);
        for(size_t i = 0; i < 3; ++i) {
            phaseCurrents[i] = -((float)motor_current_sample_adc[i] - motor_current_input_adc_offset[i]) / motor_current_input_adc_mA[i];
        }// process cosine(theta) and sine(theta)
    float phaseOffset_rad = convert2degrees((int16_t)(MAKE_SHORT( regs[REG_MOTOR_SYNCHRO_L], regs[REG_MOTOR_SYNCHRO_H])));
    float polePairs = PP, direction = REVERSE;
    float theta_rad = fmodf(absolute_position_rad * polePairs * direction, 2*PI) + phaseOffset_rad + syncOffset_rad;
    static float cos_theta = 0.0f, sin_theta = 0.0f;
    CORDIC_Processor(theta_rad, &cos_theta, &sin_theta);
        //Clarke Transformation
    float Ialpha = 2.0f / 3.0f * phaseCurrents[0] - 1.0f / 3.0f * (phaseCurrents[1] + phaseCurrents[2]);
    float Ibeta = 1.0f / sqrtf(3.0f) * (phaseCurrents[1] - phaseCurrents[2]);
		// Park Transformation
	float Id = Ialpha * cos_theta + Ibeta * sin_theta;
    float Iq = -Ialpha * sin_theta + Ibeta * cos_theta;
\end{minted}
\end{figure}
\newpage
\hfill \large Annex 5.(continued)

\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{cpp}
		// (Id,Iq) filtering
	float Id_filtered = 0.05f * Id + (0.05f) * present_Id_filtered;
    float Iq_filtered = 0.05f * Iq + (0.05f) * present_Iq_filtered;
    	// flux controller (PI+FF)
    float setpoint_Id = fluxSet_mA;
    float Flux_Kp = (float)((int16_t)(MAKE_SHORT( regs[PID_FLUX_CURRENT_KP_L], regs[PID_FLUX_CURRENT_KP_H]))) / 100000.0f;
    float error_Id = setpoint_Id - (loopStatus == 1 ? Id_filtered : 0.0f);
    float Vd = error_Id * Flux_Kp;
    float setpoint_Iq = torqueSet_mA;
    float Torque_Kp = (float)((int16_t)(MAKE_SHORT( regs[PID_TORQUE_CURRENT_KP_L], regs[PID_TORQUE_CURRENT_KP_H]))) / 100000.0f;
    float error_Iq = setpoint_Iq - (loopStatus == 1 ? Iq_filtered : 0.0f);
    float Vq = error_Iq * Torque_Kp;
		// do inverse clarke and park transformation
    float Valpha = Vd * cos_theta - Vq * sin_theta;
    float Vbeta = Vq * cos_theta + Vd * sin_theta;
        // Inverse Clarke Transformation
    float Va = Valpha;
    float Vb = (-Valpha + sqrtf(3.0f) * Vbeta) / 2.0f;
    float Vc = (-Valpha - sqrtf(3.0f) * Vbeta) / 2.0f;
    float Vneutral = 0.5f * (fmaxf(fmaxf(Va, Vb), Vc) + fminf(fminf(Va, Vb), Vc));
    	// convert (Va,Vb,Vc) to PWM duty cycles % [0.0 1.0]
	float dutyA = fconstrain(((Va - Vneutral) / present_voltage_V + 1.0f) * 0.5f, MIN_PWM_DUTY_CYCLE, MAX_PWM_DUTY_CYCLE);
}	\end{minted}
\end{figure}
\newpage
\hfill \large Annex 5.(continued)

\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{cpp}
    float dutyB = fconstrain(((Vb - Vneutral) / present_voltage_V + 1.0f) * 0.5f, MIN_PWM_DUTY_CYCLE, MAX_PWM_DUTY_CYCLE);
    float dutyC = fconstrain(((Vc - Vneutral) / present_voltage_V + 1.0f) * 0.5f, MIN_PWM_DUTY_CYCLE, MAX_PWM_DUTY_CYCLE);
        // fPWM = 16KHz
        // fTIM = 160MHz
        // ARR = fTIM/(2 * fPWM) -1 => ARR = 4999
    uint16_t CCRa = (uint16_t)(dutyA * (float)(__HAL_TIM_GET_AUTORELOAD(&htim1) + 1)) - 1;
    uint16_t CCRb = (uint16_t)(dutyB * (float)(__HAL_TIM_GET_AUTORELOAD(&htim1) + 1)) - 1;
    uint16_t CCRc = (uint16_t)(dutyC * (float)(__HAL_TIM_GET_AUTORELOAD(&htim1) + 1)) - 1;
    // update TIMER CCR register
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, CCRa);
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, CCRb);
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_3, CCRc);
		// calculate loop time
    int16_t endTime = __HAL_TIM_GET_COUNTER(&htim6);
    uint16_t processingTime = endTime - startTime;
    static const float performanceAlpha = 0.001f;
    average_processing_time_us = (1.0f - performanceAlpha) * average_processing_time_us + performanceAlpha * (float)processingTime;
    ++foc_cnt;
	\end{minted}
\end{figure}

\newpage
\apendixsection{Function for calculating the Forward Kinematics}


\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{cpp}
	CalculateFD(const JointAngles& inputAngles, RobotPose& outputPose){
    float rawInputAngles[6];
    float adjustedAngles[6];
    float cosineAngle, sineAngle;
    float cosineAlpha, sineAlpha;
    float endEffectorPosition[6];
    float endEffectorRotation[9];
    float rotationMatrices[6][9];
    float rotationMatrixPartial[4][9];  // Only need 4 as we're multiplying sequentially
    float linkVectors[4][3];  // Vectors from base to shoulder, shoulder to elbow, etc.
    // Convert input angles from degrees to radians
    for (int i = 0; i < 6; i++)
        rawInputAngles[i] = inputAngles.values[i] / DEGREES_TO_RADIANS;
    // Compute rotation matrices based on adjusted joint angles
    for (int i = 0; i < 6; i++){
        adjustedAngles[i] = rawInputAngles[i] + DHParams[i][0];
        cosineAngle = arm_cos_f32(adjustedAngles[i]);
        sineAngle = arm_sin_f32(adjustedAngles[i]);
        cosineAlpha = arm_cos_f32(DHParams[i][3]);
        sineAlpha = arm_sin_f32(DHParams[i][3]);
        // Populate each rotation matrix for the joint
        rotationMatrices[i][0] = cosineAngle;
        rotationMatrices[i][1] = -cosineAlpha * sineAngle;
        rotationMatrices[i][2] = sineAlpha * sineAngle;
        rotationMatrices[i][3] = sineAngle;
        rotationMatrices[i][4] = cosineAlpha * cosineAngle;
        rotationMatrices[i][5] = -sineAlpha * cosineAngle;
	\end{minted}
\end{figure}
\newpage
\hfill \large Annex 6.(continued)
\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{cpp}
		rotationMatrices[i][6] = 0.0f;
        rotationMatrices[i][7] = sineAlpha;
        rotationMatrices[i][8] = cosineAlpha;
    }}
	// Sequentially multiply the rotation matrices to get the cumulative rotation matrix
	MultiplyMatrices(rotationMatrices[0], rotationMatrices[1], rotationMatrixPartial[0], 3, 3, 3);
	for (int i = 1; i < 4; i++){  // Start from 1 as first multiplication already done
		MultiplyMatrices(rotationMatrixPartial[i - 1], rotationMatrices[i + 1], rotationMatrixPartial[i], 3, 3, 3);
	}
	MultiplyMatrices(rotationMatrixPartial[3], rotationMatrices[5], endEffectorRotation, 3, 3, 3);
	// Calculate position vectors for each segment in the arm's kinematic chain
	MultiplyMatrices(rotationMatrices[0], LinkBaseToShoulder, linkVectors[0], 3, 3, 1);
	MultiplyMatrices(rotationMatrixPartial[0], LinkShoulderToElbow, linkVectors[1], 3, 3, 1);
	MultiplyMatrices(rotationMatrixPartial[1], LinkElbowToWrist, linkVectors[2], 3, 3, 1);
	MultiplyMatrices(endEffectorRotation, LinkWristToEndEffector, linkVectors[3], 3, 3, 1);
	// Sum up the position vectors to get the end effector's position
	for (int i = 0; i < 3; i++)Inverse kinematics calculation function
	\end{minted}
\end{figure}

\newpage
\apendixsection{Inverse kinematics calculation function}


\begin{figure}[H]
	\centering
	\begin{minted}[tabsize=2,breaklines,fontsize=\small]{cpp}
	bool SolveIK(const Pose& targetPose, const JointStates& lastState, Solutions& solutions){
    // Initialize variables for joint angles and intermediate calculations
    float jointAngles[6], tempAngles[2], wristPos[3];
    float cosAngle, sinAngle, angle1, angle2, distSquared, dist;
    float endEffectorPos[3], endEffectorRot[9], tempRot[9], jointRot[9];
    ConvertPoseToRadians(targetPose, endEffectorPos, endEffectorRot);
    // Calculate the position of the wrist to solve for the first three joints
    CalculateWristPosition(endEffectorPos, endEffectorRot, wristPos);
    // Solve for the first three joints (base, shoulder, elbow)
    bool baseSolved = SolveBaseJoint(wristPos, jointAngles);
    bool armSolved = SolveArmJoints(wristPos, jointAngles, tempAngles);
    // If the base or arm cannot be solved, mark the solution as invalid
    MarkInvalidSolutions(baseSolved, armSolved, solutions);
    for (int i = 0; i < 2; i++)  // Loop through possible arm solutions
    {
        // Calculate the rotation matrix for the current arm solution
        CalculateArmRotationMatrix(jointAngles, tempAngles[i], tempRot);
        // Determine the wrist orientation relative to the base
        MultiplyMatrices(tempRot, endEffectorRot, jointRot, 3, 3, 3);
        // Solve for the wrist joints (roll, pitch, yaw)
        bool wristSolved = SolveWristJoints(jointRot, jointAngles + 3);
        // Store the solution if valid
        StoreSolution(wristSolved, jointAngles, solutions, i);
    }
    ConvertSolutionsToDegrees(solutions);
    return true; 
}
	\end{minted}
\end{figure}


